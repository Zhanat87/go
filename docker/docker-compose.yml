# https://docs.docker.com/compose/compose-file/#dns

###############################################################################
# Docker config
###############################################################################

version: '3'
#version: '2'

# https://github.com/docker/compose/issues/4336
# https://docs.docker.com/engine/userguide/networking/default_network/container-communication/#communicating-to-the-outside-world
# sysctl net.ipv4.conf.all.forwarding
# sudo iptables -L -n
# sudo iptables -P FORWARD ACCEPT
# sudo iptables -t nat -L -n
# sudo apt-get update && sudo apt-get install bridge-utils
# sudo brctl show
# ip route - show linkdown in 192.168.0.0/16
# docker compose user specified IP address is supported only when connecting to networks with user configured subnets
networks:
  custom_network:
    ipam:
      driver: default
      config:
        - subnet: 192.168.0.0/16

# jenkins on 8082 port - not need, .git web hooks not need
# need golang webhook for conitinuos delivery and integration - https://github.com/adnanh/webhook

services:

  # docker exec -it stack-postgres /bin/bash
  # psql -h localhost -U postgres
  # \l or \list - show databases
  # \connect stack - use db
  # \dt - show tables
  # \q - close connection and exit
  # docker inspect stack-postgres
  # docker ps
  # docker-compose up
  # https://hub.docker.com/_/postgres/
  # docker exec -it postgresql psql -U postgres -d go_restful
  postgresql:
    image: postgres:latest
#    restart: always
    container_name: postgresql
    ports:
      - "5432:5432"
    volumes:
#     not work init sql for  create and seed tables
# need run migrations in install.sh a-la 'docker run -it ...'
      - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
  #  Set environment to use a database
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=go_restful
#      - POSTGRES_HOST=172.17.0.1
#      - DB_HOST=172.17.0.1
#      - POSTGRES_PORT=5432
#      - DB_PORT=5432
#   note: if port not same like default, i.e. it was not exposed in dockerfile, need expose it here
    expose:
      - "5432"
  #  env_file:
  #    - ./postgres/.env
  #  dns: 8.8.8.8
    links:
      - postgresql1
      - postgresql2
    depends_on:
      - postgresql1
      - postgresql2
    # https://docs.docker.com/compose/networking/
    # http://docker-k8s-lab.readthedocs.io/en/latest/docker/bridged-network.html
    # https://stackoverflow.com/questions/39493490/provide-static-ip-to-docker-containers-via-docker-compose
    # https://fordodone.com/2016/03/30/docker-compose-static-ip-address-in-docker-compose-yml/
    # docker info
    # docker version
    networks:
      custom_network:
        ipv4_address: 192.168.0.4
        # note: work local, but not work in digital ocean
#      default:
#        ipv4_address: 172.18.0.4

  postgresql1:
    image: postgres:latest
    container_name: postgresql1
    ports:
      - "5433:5432"
    volumes:
      - ./postgres_1/init.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=go_restful
    expose:
      - "5432"
    networks:
      custom_network:
        ipv4_address: 192.168.0.5

  postgresql2:
    image: postgres:latest
    container_name: postgresql2
    ports:
      - "5434:5432"
    volumes:
      - ./postgres_2/init.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=go_restful
    expose:
      - "5432"
    networks:
      custom_network:
        ipv4_address: 192.168.0.6

  postgresql_replication_master:
    image: postgres:latest
    container_name: postgresql_replication_master
    ports:
      - "5435:5432"
    volumes:
      - ./postgresql_replication_master/init.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=go_restful
    expose:
      - "5432"
    networks:
      custom_network:
        ipv4_address: 192.168.0.13

  postgresql_replication_slave:
    image: postgres:latest
    container_name: postgresql_replication_slave
    ports:
      - "5436:5432"
    volumes:
      - ./postgresql_replication_slave/init.sql:/docker-entrypoint-initdb.d/init.sql
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=go_restful
    expose:
      - "5432"
    networks:
      custom_network:
        ipv4_address: 192.168.0.14
    links:
      - postgresql_replication_master
    depends_on:
      - postgresql_replication_master

  # https://github.com/ankane/pghero/blob/master/guides/Docker.md
  # https://github.com/ankane/pghero/blob/master/guides/Query-Stats.md
  pghero:
    image: ankane/pghero
    container_name: pghero
    ports:
      - "8084:8080"
    expose:
      - "8084"
    links:
      - postgresql
    depends_on:
      - postgresql
    environment:
      - DATABASE_URL=postgres://postgres:postgres@postgresql:5432/go_restful?sslmode=disable
    networks:
      custom_network:
        ipv4_address: 192.168.0.7

  redis:
    image: phpdockerio/redis:latest
    container_name: redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - ./redis-data:/data
    networks:
      custom_network:
        ipv4_address: 192.168.0.8

  # https://hub.docker.com/_/mongo/
#  mongo:
#    image: mongo
#    container_name: mongo
#    ports:
#      - "27017:27017"
#  #  environment:
#  #    - MONGO_URL=mongodb://mongodb:27019
#    command:
#      - mongod --smallfiles --quiet --logpath=/dev/null

  ###############################################################################
  # golang
  ###############################################################################

  # docker-compose logs stack-auth
  # docker-compose rm stack-auth
  # docker-compose build golang
  # https://techoverflow.net/2013/10/22/docker-remove-all-images-and-containers/
  # docker-images
  golang:
    image: zhanat87/golang:latest
  #  user: 777:777
#    restart: always
#    build:
#      context: ../
#      dockerfile: Dockerfile
#      args:
#        buildno: 1
#        password: secret
    container_name: golang
#    volumes:
#      - ./bin/go:/go/src/github.com/Zhanat87/go
    links:
      - postgresql
      - redis
      - postgresql_replication_master
      - postgresql_replication_slave
#      - mongo
    depends_on:
      - postgresql
      - redis
      - postgresql_replication_master
      - postgresql_replication_slave
#      - mongo
#    command: ["./wait-for-postgres.sh", "postgresql", "python", "test.py"]
#    command: ["./wait-for-it.sh", "postgresql:5432", "--", "echo", "postgres is up"]
#    command: ["./wait-for-it.sh", "postgresql:5433", "--", "php", "test.php"]
#      - stack-mongodb
#      - stack-rabbitmq
#    https://docs.docker.com/compose/startup-order/
#    command: ["./wait-for-it.sh", "postgresql:5432", "--", "python", "app.py"]
    ports:
      - "8080:8080"
  # https://github.com/docker/compose/issues/1809
  #  command: exec -it golang /bin/bash echo from golang
#    command:
#      - echo from golang
#      - exec -it golang /go/migrate -url postgres://postgres:postgres@172.17.0.2:5432/go_restful?sslmode=disable -path ./migrations up
  # docker exec -it golang /go/migrate -url postgres://postgres:postgres@172.17.0.2:5432/go_restful?sslmode=disable -path ./migrations up
    networks:
      custom_network:
        ipv4_address: 192.168.0.9

  golang-chat-server:
    image: zhanat87/golang-socketio-server:latest
    container_name: golang-socketio-server
    ports:
      - "5000:5000"
    networks:
      custom_network:
        ipv4_address: 192.168.0.10

  ###############################################################################
  # client-nginx
  ###############################################################################
  # docker-compose restart client-nginx
  client-nginx:
    image: phpdockerio/nginx:latest
    container_name: client-nginx
    volumes:
      - ../client:/var/www/client-nginx
  #  Inject configuration via volume
#      - ./client-nginx/nginx.conf:/etc/nginx/conf.d/default.conf
#      - ./client-nginx/passwd:/etc/nginx/conf.d/passwd
      - ./client-nginx:/etc/nginx/conf.d
      - ./client-nginx/logs:/var/log/nginx
    ports:
      - "8081:80"
    networks:
      custom_network:
        ipv4_address: 192.168.0.11

  # https://hub.docker.com/r/hardware/adminer/
  # порт adminer'а 8888, поэтому его надо перенаправить на 8083,
  # затем можно просто открыть localhost:8083
  adminer:
    image: hardware/adminer
    container_name: adminer
    ports:
      - "8888:8888"
    links:
      - postgresql
      - postgresql1
      - postgresql2
      - postgresql_replication_master
      - postgresql_replication_slave
    networks:
      custom_network:
        ipv4_address: 192.168.0.12

#  drone-server:
#      image: drone/drone:0.5
#      ports:
#        - 8000:8000
#      volumes:
#        - ./drone:/var/lib/drone/
#      restart: always
#      environment:
#        - DRONE_OPEN=true
#        - DRONE_GITHUB=true
##       https://docs.docker.com/compose/environment-variables/#setting-environment-variables-with-docker-compose-run
#        - DRONE_GITHUB_CLIENT=${DRONE_GITHUB_CLIENT}
#        - DRONE_GITHUB_SECRET=${DRONE_GITHUB_SECRET}
##        - DRONE_SECRET=${DRONE_SECRET}
#        - DRONE_SECRET=test
#        - DRONE_AGENT_SECRET=test
#  drone-agent:
#    image: drone/drone:0.5
#    command: agent
#    restart: always
#    depends_on: [ drone-server ]
##    links:
##      - drone-server
#    volumes:
#      - /var/run/docker.sock:/var/run/docker.sock
#    environment:
##      - DRONE_SERVER=ws://zhanat.site:8000/ws/broker
#      - DRONE_SERVER=ws://drone-server:8000/ws/broker
##      - DRONE_SECRET=${DRONE_SECRET}
#      - DRONE_SECRET=test
#      - DRONE_AGENT_SECRET=test

  #stack-mysql:
  ##  image: mariadb
  ##  image: mysql:5.7
  ## latest mysql image === mysql:latest
  #  image: mysql
  #  container_name: stack-mysql
  #  ports:
  ##  Error starting userland proxy: listen tcp 0.0.0.0:3306: bind: address already in use
  ##  нельзя выводить в первый порт такой же который уже занят в системе самим mysql,
  ##  надо менять наружный порт "3306:3306", например на "3333:3306"
  #    - "3333:3306"
  #  environment:
  ##    - MYSQL_USER=heaven11
  ##    - MYSQL_PASSWORD=h4UgSa
  ##    - MYSQL_ROOT_PASSWORD=h4UgSa
  ##    - MYSQL_DATABASE=heaven11-v1
  #    MYSQL_ROOT_PASSWORD: root
  #    MYSQL_DATABASE: stack_db
  ##    MYSQL_USER: dev
  ##    MYSQL_PASSWORD: 123456
  #  volumes:
  #    - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
  ##   restart: always

  #stack-memcached:
  #  image: phpdockerio/memcached:latest
  #  container_name: stack-memcached

  #stack-elasticsearch:
  #  build: .
  #  dockerfile: elasticsearch/Dockerfile
  #  container_name: stack-elasticsearch
  #  ports:
  #    - "9200:9200"
  #    - "9300:9300"

  #stack-rabbitmq:
  #  image: rabbitmq:3-management
  #  container_name: stack-rabbitmq
  #  ports:
  #    - "15672:15672"
  #    - "5672:5672"
  #  environment:
  #    - RABBITMQ_DEFAULT_USER=stack-rabbitmq
  #    - RABBITMQ_DEFAULT_PASS=stack-rabbitmq
  #    - RABBITMQ_DEFAULT_VHOST=/

  ################################################################################
  ## dictionary
  ################################################################################

  #stack-dictionary:
  #  build: ../stack-dictionary
  #  restart: always
  #  dockerfile: Dockerfile
  #  container_name: stack-dictionary
  #  volumes:
  #    - ../stack-dictionary:/usr/src/app
  ##  Expose and map ports for containers
  ##  в expose порты, которые должны быть разрешены в firewall
  ##  expose:
  ##    - 3000
  ## как в docker run -p 8081:8081
  #  ports:
  #    - "8081:8081"
  ## как в docker run --link
  #  links:
  #    - stack-mongodb
  ##    - stack-auth
  ##  Label the service
  #  labels:
  #    com.dockerinaction.chapter: "11"
  #    com.dockerinaction.example: "Coffee API"
  #    com.dockerinaction.role: "Application Logic"

  ################################################################################
  ## node.js express
  ################################################################################
  # for node.js app need first run "npm i" local and then build container
  # чтобы обновить новый код в node.js app надо просто перезапустить контейнер
  # docker-compose restart nodejs-express
  #nodejs-express:
  #  build: ../nodejs-express
  #  restart: always
  #  dockerfile: Dockerfile
  #  container_name: nodejs-express
  #  volumes:
  #    - ../nodejs-express:/usr/src/app
  #  ports:
  #    - "8081:8081"
  #  links:
  #    - stack-mongodb
